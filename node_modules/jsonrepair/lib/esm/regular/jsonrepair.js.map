{"version":3,"file":"jsonrepair.js","names":["JSONRepairError","codeAsterisk","codeBackslash","codeCloseParenthesis","codeClosingBrace","codeClosingBracket","codeColon","codeComma","codeDot","codeDoubleQuote","codeLowercaseE","codeMinus","codeNewline","codeOpeningBrace","codeOpeningBracket","codePlus","codeSemicolon","codeSlash","codeUppercaseE","endsWithCommaOrNewline","insertBeforeLastWhitespace","isControlCharacter","isDelimiter","isDigit","isDoubleQuote","isDoubleQuoteLike","isHex","isQuote","isSingleQuote","isSingleQuoteLike","isSpecialWhitespace","isStartOfValue","isUnquotedStringDelimiter","isValidStringCharacter","isWhitespace","isWhitespaceExceptNewline","regexFunctionNameChar","regexFunctionNameCharStart","regexUrlChar","regexUrlStart","removeAtIndex","stripLastOccurrence","controlCharacters","escapeCharacters","b","f","n","r","t","jsonrepair","text","i","output","processed","parseValue","throwUnexpectedEnd","processedComma","parseCharacter","parseWhitespaceAndSkipComments","parseNewlineDelimitedJSON","charCodeAt","length","throwUnexpectedCharacter","parseObject","parseArray","parseString","parseNumber","parseKeywords","parseUnquotedString","parseRegex","skipNewline","arguments","undefined","start","changed","parseWhitespace","parseComment","_isWhiteSpace","whitespace","c","atEndOfBlockComment","code","skipCharacter","skipEscapeCharacter","skipEllipsis","initial","processedKey","throwObjectKeyExpected","processedColon","truncatedText","throwColonExpected","processedValue","concat","stopAtDelimiter","stopAtIndex","skipEscapeChars","isEndQuote","iBefore","oBefore","str","iPrev","prevNonWhitespaceIndex","charAt","substring","iQuote","oQuote","parseConcatenatedString","iPrevChar","prevChar","test","char","escapeChar","slice","j","throwInvalidUnicodeCharacter","throwInvalidCharacter","parsedStr","atEndOfNumber","repairNumberEndingWithNumericSymbol","num","hasInvalidLeadingZero","parseKeyword","name","value","isKey","symbol","JSON","stringify","prev","chars"],"sources":["../../../src/regular/jsonrepair.ts"],"sourcesContent":["import { JSONRepairError } from '../utils/JSONRepairError.js'\nimport {\n  codeAsterisk,\n  codeBackslash,\n  codeCloseParenthesis,\n  codeClosingBrace,\n  codeClosingBracket,\n  codeColon,\n  codeComma,\n  codeDot,\n  codeDoubleQuote,\n  codeLowercaseE,\n  codeMinus,\n  codeNewline,\n  codeOpeningBrace,\n  codeOpeningBracket,\n  codePlus,\n  codeSemicolon,\n  codeSlash,\n  codeUppercaseE,\n  endsWithCommaOrNewline,\n  insertBeforeLastWhitespace,\n  isControlCharacter,\n  isDelimiter,\n  isDigit,\n  isDoubleQuote,\n  isDoubleQuoteLike,\n  isHex,\n  isQuote,\n  isSingleQuote,\n  isSingleQuoteLike,\n  isSpecialWhitespace,\n  isStartOfValue,\n  isUnquotedStringDelimiter,\n  isValidStringCharacter,\n  isWhitespace,\n  isWhitespaceExceptNewline,\n  regexFunctionNameChar,\n  regexFunctionNameCharStart,\n  regexUrlChar,\n  regexUrlStart,\n  removeAtIndex,\n  stripLastOccurrence\n} from '../utils/stringUtils.js'\n\nconst controlCharacters: { [key: string]: string } = {\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t'\n}\n\n// map with all escape characters\nconst escapeCharacters: { [key: string]: string } = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n}\n\n/**\n * Repair a string containing an invalid JSON document.\n * For example changes JavaScript notation into JSON notation.\n *\n * Example:\n *\n *     try {\n *       const json = \"{name: 'John'}\"\n *       const repaired = jsonrepair(json)\n *       console.log(repaired)\n *       // '{\"name\": \"John\"}'\n *     } catch (err) {\n *       console.error(err)\n *     }\n *\n */\nexport function jsonrepair(text: string): string {\n  let i = 0 // current index in text\n  let output = '' // generated output\n\n  const processed = parseValue()\n  if (!processed) {\n    throwUnexpectedEnd()\n  }\n\n  const processedComma = parseCharacter(codeComma)\n  if (processedComma) {\n    parseWhitespaceAndSkipComments()\n  }\n\n  if (isStartOfValue(text[i]) && endsWithCommaOrNewline(output)) {\n    // start of a new value after end of the root level object: looks like\n    // newline delimited JSON -> turn into a root level array\n    if (!processedComma) {\n      // repair missing comma\n      output = insertBeforeLastWhitespace(output, ',')\n    }\n\n    parseNewlineDelimitedJSON()\n  } else if (processedComma) {\n    // repair: remove trailing comma\n    output = stripLastOccurrence(output, ',')\n  }\n\n  // repair redundant end quotes\n  while (text.charCodeAt(i) === codeClosingBrace || text.charCodeAt(i) === codeClosingBracket) {\n    i++\n    parseWhitespaceAndSkipComments()\n  }\n\n  if (i >= text.length) {\n    // reached the end of the document properly\n    return output\n  }\n\n  throwUnexpectedCharacter()\n\n  function parseValue(): boolean {\n    parseWhitespaceAndSkipComments()\n    const processed =\n      parseObject() ||\n      parseArray() ||\n      parseString() ||\n      parseNumber() ||\n      parseKeywords() ||\n      parseUnquotedString(false) ||\n      parseRegex()\n    parseWhitespaceAndSkipComments()\n\n    return processed\n  }\n\n  function parseWhitespaceAndSkipComments(skipNewline = true): boolean {\n    const start = i\n\n    let changed = parseWhitespace(skipNewline)\n    do {\n      changed = parseComment()\n      if (changed) {\n        changed = parseWhitespace(skipNewline)\n      }\n    } while (changed)\n\n    return i > start\n  }\n\n  function parseWhitespace(skipNewline: boolean): boolean {\n    const _isWhiteSpace = skipNewline ? isWhitespace : isWhitespaceExceptNewline\n    let whitespace = ''\n\n    while (true) {\n      const c = text.charCodeAt(i)\n      if (_isWhiteSpace(c)) {\n        whitespace += text[i]\n        i++\n      } else if (isSpecialWhitespace(c)) {\n        // repair special whitespace\n        whitespace += ' '\n        i++\n      } else {\n        break\n      }\n    }\n\n    if (whitespace.length > 0) {\n      output += whitespace\n      return true\n    }\n\n    return false\n  }\n\n  function parseComment(): boolean {\n    // find a block comment '/* ... */'\n    if (text.charCodeAt(i) === codeSlash && text.charCodeAt(i + 1) === codeAsterisk) {\n      // repair block comment by skipping it\n      while (i < text.length && !atEndOfBlockComment(text, i)) {\n        i++\n      }\n      i += 2\n\n      return true\n    }\n\n    // find a line comment '// ...'\n    if (text.charCodeAt(i) === codeSlash && text.charCodeAt(i + 1) === codeSlash) {\n      // repair line comment by skipping it\n      while (i < text.length && text.charCodeAt(i) !== codeNewline) {\n        i++\n      }\n\n      return true\n    }\n\n    return false\n  }\n\n  function parseCharacter(code: number): boolean {\n    if (text.charCodeAt(i) === code) {\n      output += text[i]\n      i++\n      return true\n    }\n\n    return false\n  }\n\n  function skipCharacter(code: number): boolean {\n    if (text.charCodeAt(i) === code) {\n      i++\n      return true\n    }\n\n    return false\n  }\n\n  function skipEscapeCharacter(): boolean {\n    return skipCharacter(codeBackslash)\n  }\n\n  /**\n   * Skip ellipsis like \"[1,2,3,...]\" or \"[1,2,3,...,9]\" or \"[...,7,8,9]\"\n   * or a similar construct in objects.\n   */\n  function skipEllipsis(): boolean {\n    parseWhitespaceAndSkipComments()\n\n    if (\n      text.charCodeAt(i) === codeDot &&\n      text.charCodeAt(i + 1) === codeDot &&\n      text.charCodeAt(i + 2) === codeDot\n    ) {\n      // repair: remove the ellipsis (three dots) and optionally a comma\n      i += 3\n      parseWhitespaceAndSkipComments()\n      skipCharacter(codeComma)\n\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Parse an object like '{\"key\": \"value\"}'\n   */\n  function parseObject(): boolean {\n    if (text.charCodeAt(i) === codeOpeningBrace) {\n      output += '{'\n      i++\n      parseWhitespaceAndSkipComments()\n\n      // repair: skip leading comma like in {, message: \"hi\"}\n      if (skipCharacter(codeComma)) {\n        parseWhitespaceAndSkipComments()\n      }\n\n      let initial = true\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBrace) {\n        let processedComma: boolean\n        if (!initial) {\n          processedComma = parseCharacter(codeComma)\n          if (!processedComma) {\n            // repair missing comma\n            output = insertBeforeLastWhitespace(output, ',')\n          }\n          parseWhitespaceAndSkipComments()\n        } else {\n          processedComma = true\n          initial = false\n        }\n\n        skipEllipsis()\n\n        const processedKey = parseString() || parseUnquotedString(true)\n        if (!processedKey) {\n          if (\n            text.charCodeAt(i) === codeClosingBrace ||\n            text.charCodeAt(i) === codeOpeningBrace ||\n            text.charCodeAt(i) === codeClosingBracket ||\n            text.charCodeAt(i) === codeOpeningBracket ||\n            text[i] === undefined\n          ) {\n            // repair trailing comma\n            output = stripLastOccurrence(output, ',')\n          } else {\n            throwObjectKeyExpected()\n          }\n          break\n        }\n\n        parseWhitespaceAndSkipComments()\n        const processedColon = parseCharacter(codeColon)\n        const truncatedText = i >= text.length\n        if (!processedColon) {\n          if (isStartOfValue(text[i]) || truncatedText) {\n            // repair missing colon\n            output = insertBeforeLastWhitespace(output, ':')\n          } else {\n            throwColonExpected()\n          }\n        }\n        const processedValue = parseValue()\n        if (!processedValue) {\n          if (processedColon || truncatedText) {\n            // repair missing object value\n            output += 'null'\n          } else {\n            throwColonExpected()\n          }\n        }\n      }\n\n      if (text.charCodeAt(i) === codeClosingBrace) {\n        output += '}'\n        i++\n      } else {\n        // repair missing end bracket\n        output = insertBeforeLastWhitespace(output, '}')\n      }\n\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Parse an array like '[\"item1\", \"item2\", ...]'\n   */\n  function parseArray(): boolean {\n    if (text.charCodeAt(i) === codeOpeningBracket) {\n      output += '['\n      i++\n      parseWhitespaceAndSkipComments()\n\n      // repair: skip leading comma like in [,1,2,3]\n      if (skipCharacter(codeComma)) {\n        parseWhitespaceAndSkipComments()\n      }\n\n      let initial = true\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBracket) {\n        if (!initial) {\n          const processedComma = parseCharacter(codeComma)\n          if (!processedComma) {\n            // repair missing comma\n            output = insertBeforeLastWhitespace(output, ',')\n          }\n        } else {\n          initial = false\n        }\n\n        skipEllipsis()\n\n        const processedValue = parseValue()\n        if (!processedValue) {\n          // repair trailing comma\n          output = stripLastOccurrence(output, ',')\n          break\n        }\n      }\n\n      if (text.charCodeAt(i) === codeClosingBracket) {\n        output += ']'\n        i++\n      } else {\n        // repair missing closing array bracket\n        output = insertBeforeLastWhitespace(output, ']')\n      }\n\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Parse and repair Newline Delimited JSON (NDJSON):\n   * multiple JSON objects separated by a newline character\n   */\n  function parseNewlineDelimitedJSON() {\n    // repair NDJSON\n    let initial = true\n    let processedValue = true\n    while (processedValue) {\n      if (!initial) {\n        // parse optional comma, insert when missing\n        const processedComma = parseCharacter(codeComma)\n        if (!processedComma) {\n          // repair: add missing comma\n          output = insertBeforeLastWhitespace(output, ',')\n        }\n      } else {\n        initial = false\n      }\n\n      processedValue = parseValue()\n    }\n\n    if (!processedValue) {\n      // repair: remove trailing comma\n      output = stripLastOccurrence(output, ',')\n    }\n\n    // repair: wrap the output inside array brackets\n    output = `[\\n${output}\\n]`\n  }\n\n  /**\n   * Parse a string enclosed by double quotes \"...\". Can contain escaped quotes\n   * Repair strings enclosed in single quotes or special quotes\n   * Repair an escaped string\n   *\n   * The function can run in two stages:\n   * - First, it assumes the string has a valid end quote\n   * - If it turns out that the string does not have a valid end quote followed\n   *   by a delimiter (which should be the case), the function runs again in a\n   *   more conservative way, stopping the string at the first next delimiter\n   *   and fixing the string by inserting a quote there, or stopping at a\n   *   stop index detected in the first iteration.\n   */\n  function parseString(stopAtDelimiter = false, stopAtIndex = -1): boolean {\n    let skipEscapeChars = text.charCodeAt(i) === codeBackslash\n    if (skipEscapeChars) {\n      // repair: remove the first escape character\n      i++\n      skipEscapeChars = true\n    }\n\n    if (isQuote(text.charCodeAt(i))) {\n      // double quotes are correct JSON,\n      // single quotes come from JavaScript for example, we assume it will have a correct single end quote too\n      // otherwise, we will match any double-quote-like start with a double-quote-like end,\n      // or any single-quote-like start with a single-quote-like end\n      const isEndQuote = isDoubleQuote(text.charCodeAt(i))\n        ? isDoubleQuote\n        : isSingleQuote(text.charCodeAt(i))\n          ? isSingleQuote\n          : isSingleQuoteLike(text.charCodeAt(i))\n            ? isSingleQuoteLike\n            : isDoubleQuoteLike\n\n      const iBefore = i\n      const oBefore = output.length\n\n      let str = '\"'\n      i++\n\n      while (true) {\n        if (i >= text.length) {\n          // end of text, we are missing an end quote\n\n          const iPrev = prevNonWhitespaceIndex(i - 1)\n          if (!stopAtDelimiter && isDelimiter(text.charAt(iPrev))) {\n            // if the text ends with a delimiter, like [\"hello],\n            // so the missing end quote should be inserted before this delimiter\n            // retry parsing the string, stopping at the first next delimiter\n            i = iBefore\n            output = output.substring(0, oBefore)\n\n            return parseString(true)\n          }\n\n          // repair missing quote\n          str = insertBeforeLastWhitespace(str, '\"')\n          output += str\n\n          return true\n          // biome-ignore lint/style/noUselessElse: <explanation>\n        } else if (i === stopAtIndex) {\n          // use the stop index detected in the first iteration, and repair end quote\n          str = insertBeforeLastWhitespace(str, '\"')\n          output += str\n\n          return true\n          // biome-ignore lint/style/noUselessElse: <explanation>\n        } else if (isEndQuote(text.charCodeAt(i))) {\n          // end quote\n          // let us check what is before and after the quote to verify whether this is a legit end quote\n          const iQuote = i\n          const oQuote = str.length\n          str += '\"'\n          i++\n          output += str\n\n          parseWhitespaceAndSkipComments(false)\n\n          if (\n            stopAtDelimiter ||\n            i >= text.length ||\n            isDelimiter(text.charAt(i)) ||\n            isQuote(text.charCodeAt(i)) ||\n            isDigit(text.charCodeAt(i))\n          ) {\n            // The quote is followed by the end of the text, a delimiter,\n            // or a next value. So the quote is indeed the end of the string.\n            parseConcatenatedString()\n\n            return true\n          }\n\n          const iPrevChar = prevNonWhitespaceIndex(iQuote - 1)\n          const prevChar = text.charAt(iPrevChar)\n\n          if (prevChar === ',') {\n            // A comma followed by a quote, like '{\"a\":\"b,c,\"d\":\"e\"}'.\n            // We assume that the quote is a start quote, and that the end quote\n            // should have been located right before the comma but is missing.\n            i = iBefore\n            output = output.substring(0, oBefore)\n\n            return parseString(false, iPrevChar)\n          }\n\n          if (isDelimiter(prevChar)) {\n            // This is not the right end quote: it is preceded by a delimiter,\n            // and NOT followed by a delimiter. So, there is an end quote missing\n            // parse the string again and then stop at the first next delimiter\n            i = iBefore\n            output = output.substring(0, oBefore)\n\n            return parseString(true)\n          }\n\n          // revert to right after the quote but before any whitespace, and continue parsing the string\n          output = output.substring(0, oBefore)\n          i = iQuote + 1\n\n          // repair unescaped quote\n          str = `${str.substring(0, oQuote)}\\\\${str.substring(oQuote)}`\n        } else if (stopAtDelimiter && isUnquotedStringDelimiter(text[i])) {\n          // we're in the mode to stop the string at the first delimiter\n          // because there is an end quote missing\n\n          // test start of an url like \"https://...\" (this would be parsed as a comment)\n          if (\n            text.charCodeAt(i - 1) === codeColon &&\n            regexUrlStart.test(text.substring(iBefore + 1, i + 2))\n          ) {\n            while (i < text.length && regexUrlChar.test(text[i])) {\n              str += text[i]\n              i++\n            }\n          }\n\n          // repair missing quote\n          str = insertBeforeLastWhitespace(str, '\"')\n          output += str\n\n          parseConcatenatedString()\n\n          return true\n        } else if (text.charCodeAt(i) === codeBackslash) {\n          // handle escaped content like \\n or \\u2605\n          const char = text.charAt(i + 1)\n          const escapeChar = escapeCharacters[char]\n          if (escapeChar !== undefined) {\n            str += text.slice(i, i + 2)\n            i += 2\n          } else if (char === 'u') {\n            let j = 2\n            while (j < 6 && isHex(text.charCodeAt(i + j))) {\n              j++\n            }\n\n            if (j === 6) {\n              str += text.slice(i, i + 6)\n              i += 6\n            } else if (i + j >= text.length) {\n              // repair invalid or truncated unicode char at the end of the text\n              // by removing the unicode char and ending the string here\n              i = text.length\n            } else {\n              throwInvalidUnicodeCharacter()\n            }\n          } else {\n            // repair invalid escape character: remove it\n            str += char\n            i += 2\n          }\n        } else {\n          // handle regular characters\n          const char = text.charAt(i)\n          const code = text.charCodeAt(i)\n\n          if (code === codeDoubleQuote && text.charCodeAt(i - 1) !== codeBackslash) {\n            // repair unescaped double quote\n            str += `\\\\${char}`\n            i++\n          } else if (isControlCharacter(code)) {\n            // unescaped control character\n            str += controlCharacters[char]\n            i++\n          } else {\n            if (!isValidStringCharacter(code)) {\n              throwInvalidCharacter(char)\n            }\n            str += char\n            i++\n          }\n        }\n\n        if (skipEscapeChars) {\n          // repair: skipped escape character (nothing to do)\n          skipEscapeCharacter()\n        }\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Repair concatenated strings like \"hello\" + \"world\", change this into \"helloworld\"\n   */\n  function parseConcatenatedString(): boolean {\n    let processed = false\n\n    parseWhitespaceAndSkipComments()\n    while (text.charCodeAt(i) === codePlus) {\n      processed = true\n      i++\n      parseWhitespaceAndSkipComments()\n\n      // repair: remove the end quote of the first string\n      output = stripLastOccurrence(output, '\"', true)\n      const start = output.length\n      const parsedStr = parseString()\n      if (parsedStr) {\n        // repair: remove the start quote of the second string\n        output = removeAtIndex(output, start, 1)\n      } else {\n        // repair: remove the + because it is not followed by a string\n        output = insertBeforeLastWhitespace(output, '\"')\n      }\n    }\n\n    return processed\n  }\n\n  /**\n   * Parse a number like 2.4 or 2.4e6\n   */\n  function parseNumber(): boolean {\n    const start = i\n    if (text.charCodeAt(i) === codeMinus) {\n      i++\n      if (atEndOfNumber()) {\n        repairNumberEndingWithNumericSymbol(start)\n        return true\n      }\n      if (!isDigit(text.charCodeAt(i))) {\n        i = start\n        return false\n      }\n    }\n\n    // Note that in JSON leading zeros like \"00789\" are not allowed.\n    // We will allow all leading zeros here though and at the end of parseNumber\n    // check against trailing zeros and repair that if needed.\n    // Leading zeros can have meaning, so we should not clear them.\n    while (isDigit(text.charCodeAt(i))) {\n      i++\n    }\n\n    if (text.charCodeAt(i) === codeDot) {\n      i++\n      if (atEndOfNumber()) {\n        repairNumberEndingWithNumericSymbol(start)\n        return true\n      }\n      if (!isDigit(text.charCodeAt(i))) {\n        i = start\n        return false\n      }\n      while (isDigit(text.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    if (text.charCodeAt(i) === codeLowercaseE || text.charCodeAt(i) === codeUppercaseE) {\n      i++\n      if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {\n        i++\n      }\n      if (atEndOfNumber()) {\n        repairNumberEndingWithNumericSymbol(start)\n        return true\n      }\n      if (!isDigit(text.charCodeAt(i))) {\n        i = start\n        return false\n      }\n      while (isDigit(text.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    // if we're not at the end of the number by this point, allow this to be parsed as another type\n    if (!atEndOfNumber()) {\n      i = start\n      return false\n    }\n\n    if (i > start) {\n      // repair a number with leading zeros like \"00789\"\n      const num = text.slice(start, i)\n      const hasInvalidLeadingZero = /^0\\d/.test(num)\n\n      output += hasInvalidLeadingZero ? `\"${num}\"` : num\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Parse keywords true, false, null\n   * Repair Python keywords True, False, None\n   */\n  function parseKeywords(): boolean {\n    return (\n      parseKeyword('true', 'true') ||\n      parseKeyword('false', 'false') ||\n      parseKeyword('null', 'null') ||\n      // repair Python keywords True, False, None\n      parseKeyword('True', 'true') ||\n      parseKeyword('False', 'false') ||\n      parseKeyword('None', 'null')\n    )\n  }\n\n  function parseKeyword(name: string, value: string): boolean {\n    if (text.slice(i, i + name.length) === name) {\n      output += value\n      i += name.length\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Repair an unquoted string by adding quotes around it\n   * Repair a MongoDB function call like NumberLong(\"2\")\n   * Repair a JSONP function call like callback({...});\n   */\n  function parseUnquotedString(isKey: boolean) {\n    // note that the symbol can end with whitespaces: we stop at the next delimiter\n    // also, note that we allow strings to contain a slash / in order to support repairing regular expressions\n    const start = i\n\n    if (regexFunctionNameCharStart.test(text[i])) {\n      while (i < text.length && regexFunctionNameChar.test(text[i])) {\n        i++\n      }\n\n      let j = i\n      while (isWhitespace(text.charCodeAt(j))) {\n        j++\n      }\n\n      if (text[j] === '(') {\n        // repair a MongoDB function call like NumberLong(\"2\")\n        // repair a JSONP function call like callback({...});\n        i = j + 1\n\n        parseValue()\n\n        if (text.charCodeAt(i) === codeCloseParenthesis) {\n          // repair: skip close bracket of function call\n          i++\n          if (text.charCodeAt(i) === codeSemicolon) {\n            // repair: skip semicolon after JSONP call\n            i++\n          }\n        }\n\n        return true\n      }\n    }\n\n    while (\n      i < text.length &&\n      !isUnquotedStringDelimiter(text[i]) &&\n      !isQuote(text.charCodeAt(i)) &&\n      (!isKey || text.charCodeAt(i) !== codeColon)\n    ) {\n      i++\n    }\n\n    // test start of an url like \"https://...\" (this would be parsed as a comment)\n    if (text.charCodeAt(i - 1) === codeColon && regexUrlStart.test(text.substring(start, i + 2))) {\n      while (i < text.length && regexUrlChar.test(text[i])) {\n        i++\n      }\n    }\n\n    if (i > start) {\n      // repair unquoted string\n      // also, repair undefined into null\n\n      // first, go back to prevent getting trailing whitespaces in the string\n      while (isWhitespace(text.charCodeAt(i - 1)) && i > 0) {\n        i--\n      }\n\n      const symbol = text.slice(start, i)\n      output += symbol === 'undefined' ? 'null' : JSON.stringify(symbol)\n\n      if (text.charCodeAt(i) === codeDoubleQuote) {\n        // we had a missing start quote, but now we encountered the end quote, so we can skip that one\n        i++\n      }\n\n      return true\n    }\n  }\n\n  function parseRegex() {\n    if (text[i] === '/') {\n      const start = i\n      i++\n\n      while (i < text.length && (text[i] !== '/' || text[i - 1] === '\\\\')) {\n        i++\n      }\n      i++\n\n      output += `\"${text.substring(start, i)}\"`\n\n      return true\n    }\n  }\n\n  function prevNonWhitespaceIndex(start: number): number {\n    let prev = start\n\n    while (prev > 0 && isWhitespace(text.charCodeAt(prev))) {\n      prev--\n    }\n\n    return prev\n  }\n\n  function atEndOfNumber() {\n    return i >= text.length || isDelimiter(text[i]) || isWhitespace(text.charCodeAt(i))\n  }\n\n  function repairNumberEndingWithNumericSymbol(start: number) {\n    // repair numbers cut off at the end\n    // this will only be called when we end after a '.', '-', or 'e' and does not\n    // change the number more than it needs to make it valid JSON\n    output += `${text.slice(start, i)}0`\n  }\n\n  function throwInvalidCharacter(char: string) {\n    throw new JSONRepairError(`Invalid character ${JSON.stringify(char)}`, i)\n  }\n\n  function throwUnexpectedCharacter() {\n    throw new JSONRepairError(`Unexpected character ${JSON.stringify(text[i])}`, i)\n  }\n\n  function throwUnexpectedEnd() {\n    throw new JSONRepairError('Unexpected end of json string', text.length)\n  }\n\n  function throwObjectKeyExpected() {\n    throw new JSONRepairError('Object key expected', i)\n  }\n\n  function throwColonExpected() {\n    throw new JSONRepairError('Colon expected', i)\n  }\n\n  function throwInvalidUnicodeCharacter() {\n    const chars = text.slice(i, i + 6)\n    throw new JSONRepairError(`Invalid unicode character \"${chars}\"`, i)\n  }\n}\n\nfunction atEndOfBlockComment(text: string, i: number) {\n  return text[i] === '*' && text[i + 1] === '/'\n}\n"],"mappings":"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","ignoreList":[]}